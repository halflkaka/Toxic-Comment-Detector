{"ast":null,"code":"/**\n * @ignore\n * css3 selector engine for ie6-8\n * @author yiminghe@gmail.com\n */\nvar util = require('./query-selector/util');\n\nvar parser = require('./query-selector/parser');\n\nvar EXPANDO_SELECTOR_KEY = '_ks_data_selector_id_',\n    caches = {},\n    isContextXML,\n    uuid = 0,\n    subMatchesCache = {},\n    getAttr = function getAttr(el, name) {\n  if (isContextXML) {\n    return util.getSimpleAttr(el, name);\n  } else {\n    return util.attr(el, name);\n  }\n},\n    hasSingleClass = util.hasSingleClass,\n    isTag = util.isTag,\n    aNPlusB = /^(([+-]?(?:\\d+)?)?n)?([+-]?\\d+)?$/; // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\n\nvar unescape = /\\\\([\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|.)/g,\n    unescapeFn = function unescapeFn(_, escaped) {\n  var high = '0x' + escaped - 0x10000; // NaN means non-codepoint\n\n  return isNaN(high) ? escaped : // BMP codepoint\n  high < 0 ? String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n  String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n};\n\nvar matchExpr;\nvar pseudoFnExpr = {\n  'nth-child': function nthChild(el, param) {\n    var ab = getAb(param),\n        a = ab.a,\n        b = ab.b;\n\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n\n    var index = 0,\n        parent = el.parentNode;\n\n    if (parent) {\n      var childNodes = parent.childNodes,\n          count = 0,\n          child,\n          ret,\n          len = childNodes.length;\n\n      for (; count < len; count++) {\n        child = childNodes[count];\n\n        if (child.nodeType === 1) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n\n    return 0;\n  },\n  'nth-last-child': function nthLastChild(el, param) {\n    var ab = getAb(param),\n        a = ab.a,\n        b = ab.b;\n\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n\n    var index = 0,\n        parent = el.parentNode;\n\n    if (parent) {\n      var childNodes = parent.childNodes,\n          len = childNodes.length,\n          count = len - 1,\n          child,\n          ret;\n\n      for (; count >= 0; count--) {\n        child = childNodes[count];\n\n        if (child.nodeType === 1) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n\n    return 0;\n  },\n  'nth-of-type': function nthOfType(el, param) {\n    var ab = getAb(param),\n        a = ab.a,\n        b = ab.b;\n\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n\n    var index = 0,\n        parent = el.parentNode;\n\n    if (parent) {\n      var childNodes = parent.childNodes,\n          elType = el.tagName,\n          count = 0,\n          child,\n          ret,\n          len = childNodes.length;\n\n      for (; count < len; count++) {\n        child = childNodes[count];\n\n        if (child.tagName === elType) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n\n    return 0;\n  },\n  'nth-last-of-type': function nthLastOfType(el, param) {\n    var ab = getAb(param),\n        a = ab.a,\n        b = ab.b;\n\n    if (a === 0 && b === 0) {\n      return 0;\n    }\n\n    var index = 0,\n        parent = el.parentNode;\n\n    if (parent) {\n      var childNodes = parent.childNodes,\n          len = childNodes.length,\n          elType = el.tagName,\n          count = len - 1,\n          child,\n          ret;\n\n      for (; count >= 0; count--) {\n        child = childNodes[count];\n\n        if (child.tagName === elType) {\n          index++;\n          ret = matchIndexByAb(index, a, b, child === el);\n\n          if (ret !== undefined) {\n            return ret;\n          }\n        }\n      }\n    }\n\n    return 0;\n  },\n  lang: function lang(el, _lang) {\n    var elLang;\n    _lang = unEscape(_lang.toLowerCase());\n\n    do {\n      if (elLang = isContextXML ? el.getAttribute('xml:lang') || el.getAttribute('lang') : el.lang) {\n        elLang = elLang.toLowerCase();\n        return elLang === _lang || elLang.indexOf(_lang + '-') === 0;\n      }\n    } while ((el = el.parentNode) && el.nodeType === 1);\n\n    return false;\n  },\n  not: function not(el, negationArg) {\n    return !matchExpr[negationArg.t](el, negationArg.value);\n  }\n};\nvar pseudoIdentExpr = {\n  empty: function empty(el) {\n    var childNodes = el.childNodes,\n        index = 0,\n        len = childNodes.length - 1,\n        child,\n        nodeType;\n\n    for (; index < len; index++) {\n      child = childNodes[index];\n      nodeType = child.nodeType; // only element nodes and content nodes\n      // (such as Dom [Dom-LEVEL-3-CORE] text nodes,\n      // CDATA nodes, and entity references\n\n      if (nodeType === 1 || nodeType === 3 || nodeType === 4 || nodeType === 5) {\n        return 0;\n      }\n    }\n\n    return 1;\n  },\n  root: function root(el) {\n    if (el.nodeType === 9) {\n      return true;\n    }\n\n    return el.ownerDocument && el === el.ownerDocument.documentElement;\n  },\n  'first-child': function firstChild(el) {\n    return pseudoFnExpr['nth-child'](el, 1);\n  },\n  'last-child': function lastChild(el) {\n    return pseudoFnExpr['nth-last-child'](el, 1);\n  },\n  'first-of-type': function firstOfType(el) {\n    return pseudoFnExpr['nth-of-type'](el, 1);\n  },\n  'last-of-type': function lastOfType(el) {\n    return pseudoFnExpr['nth-last-of-type'](el, 1);\n  },\n  'only-child': function onlyChild(el) {\n    return pseudoIdentExpr['first-child'](el) && pseudoIdentExpr['last-child'](el);\n  },\n  'only-of-type': function onlyOfType(el) {\n    return pseudoIdentExpr['first-of-type'](el) && pseudoIdentExpr['last-of-type'](el);\n  },\n  focus: function focus(el) {\n    var doc = el.ownerDocument;\n    return doc && el === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(el.type || el.href || el.tabIndex >= 0);\n  },\n  target: function target(el) {\n    var hash = location.hash;\n    return hash && hash.slice(1) === getAttr(el, 'id');\n  },\n  enabled: function enabled(el) {\n    return !el.disabled;\n  },\n  disabled: function disabled(el) {\n    return el.disabled;\n  },\n  checked: function checked(el) {\n    var nodeName = el.nodeName.toLowerCase();\n    return nodeName === 'input' && el.checked || nodeName === 'option' && el.selected;\n  }\n};\nvar attributeExpr = {\n  '~=': function _(elValue, value) {\n    if (!value || value.indexOf(' ') > -1) {\n      return 0;\n    }\n\n    return (' ' + elValue + ' ').indexOf(' ' + value + ' ') !== -1;\n  },\n  '|=': function _(elValue, value) {\n    return (' ' + elValue).indexOf(' ' + value + '-') !== -1;\n  },\n  '^=': function _(elValue, value) {\n    return value && util.startsWith(elValue, value);\n  },\n  '$=': function $(elValue, value) {\n    return value && util.endsWith(elValue, value);\n  },\n  '*=': function _(elValue, value) {\n    return value && elValue.indexOf(value) !== -1;\n  },\n  '=': function _(elValue, value) {\n    return elValue === value;\n  }\n};\nvar relativeExpr = {\n  '>': {\n    dir: 'parentNode',\n    immediate: 1\n  },\n  ' ': {\n    dir: 'parentNode'\n  },\n  '+': {\n    dir: 'previousSibling',\n    immediate: 1\n  },\n  '~': {\n    dir: 'previousSibling'\n  }\n};\nmatchExpr = {\n  tag: isTag,\n  cls: hasSingleClass,\n  id: function id(el, value) {\n    return getAttr(el, 'id') === value;\n  },\n  attrib: function attrib(el, value) {\n    var name = value.ident;\n\n    if (!isContextXML) {\n      name = name.toLowerCase();\n    }\n\n    var elValue = getAttr(el, name);\n    var match = value.match;\n\n    if (!match && elValue !== undefined) {\n      return 1;\n    } else if (match) {\n      if (elValue === undefined) {\n        return 0;\n      }\n\n      var matchFn = attributeExpr[match];\n\n      if (matchFn) {\n        return matchFn(elValue + '', value.value + '');\n      }\n    }\n\n    return 0;\n  },\n  pseudo: function pseudo(el, value) {\n    var fn, fnStr, ident;\n\n    if (fnStr = value.fn) {\n      if (!(fn = pseudoFnExpr[fnStr])) {\n        throw new SyntaxError('Syntax error: not support pseudo: ' + fnStr);\n      }\n\n      return fn(el, value.param);\n    }\n\n    if (ident = value.ident) {\n      if (!pseudoIdentExpr[ident]) {\n        throw new SyntaxError('Syntax error: not support pseudo: ' + ident);\n      }\n\n      return pseudoIdentExpr[ident](el);\n    }\n\n    return 0;\n  }\n};\n\nfunction unEscape(str) {\n  return str.replace(unescape, unescapeFn);\n}\n\nparser.lexer.yy = {\n  trim: util.trim,\n  unEscape: unEscape,\n  unEscapeStr: function unEscapeStr(str) {\n    return this.unEscape(str.slice(1, -1));\n  }\n};\n\nfunction resetStatus() {\n  subMatchesCache = {};\n}\n\nfunction dir(el, direction) {\n  do {\n    el = el[direction];\n  } while (el && el.nodeType !== 1);\n\n  return el;\n}\n\nfunction getAb(param) {\n  var a = 0,\n      match,\n      b = 0;\n\n  if (typeof param === 'number') {\n    b = param;\n  } else if (param === 'odd') {\n    a = 2;\n    b = 1;\n  } else if (param === 'even') {\n    a = 2;\n    b = 0;\n  } else if (match = param.replace(/\\s/g, '').match(aNPlusB)) {\n    if (match[1]) {\n      a = parseInt(match[2], 10);\n\n      if (isNaN(a)) {\n        if (match[2] === '-') {\n          a = -1;\n        } else {\n          a = 1;\n        }\n      }\n    } else {\n      a = 0;\n    }\n\n    b = parseInt(match[3], 10) || 0;\n  }\n\n  return {\n    a: a,\n    b: b\n  };\n}\n\nfunction matchIndexByAb(index, a, b, eq) {\n  if (a === 0) {\n    if (index === b) {\n      return eq;\n    }\n  } else {\n    if ((index - b) / a >= 0 && (index - b) % a === 0 && eq) {\n      return 1;\n    }\n  }\n\n  return undefined;\n}\n\nfunction isXML(elem) {\n  var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n  return documentElement ? documentElement.nodeName.toLowerCase() !== 'html' : false;\n}\n\nfunction matches(str, seeds) {\n  return select(str, null, seeds);\n}\n\nfunction singleMatch(el, match) {\n  if (!match) {\n    return true;\n  }\n\n  if (!el) {\n    return false;\n  }\n\n  if (el.nodeType === 9) {\n    return false;\n  }\n\n  var matched = 1,\n      matchSuffix = match.suffix,\n      matchSuffixLen,\n      matchSuffixIndex;\n\n  if (match.t === 'tag') {\n    matched &= matchExpr.tag(el, match.value);\n  }\n\n  if (matched && matchSuffix) {\n    matchSuffixLen = matchSuffix.length;\n    matchSuffixIndex = 0;\n\n    for (; matched && matchSuffixIndex < matchSuffixLen; matchSuffixIndex++) {\n      var singleMatchSuffix = matchSuffix[matchSuffixIndex],\n          singleMatchSuffixType = singleMatchSuffix.t;\n\n      if (matchExpr[singleMatchSuffixType]) {\n        matched &= matchExpr[singleMatchSuffixType](el, singleMatchSuffix.value);\n      }\n    }\n  }\n\n  return matched;\n} // match by adjacent immediate single selector match\n\n\nfunction matchImmediate(el, match) {\n  var matched = 1,\n      startEl = el,\n      relativeOp,\n      startMatch = match;\n\n  do {\n    matched &= singleMatch(el, match);\n\n    if (matched) {\n      // advance\n      match = match && match.prev;\n\n      if (!match) {\n        return true;\n      }\n\n      relativeOp = relativeExpr[match.nextCombinator];\n      el = dir(el, relativeOp.dir);\n\n      if (!relativeOp.immediate) {\n        return {\n          // advance for non-immediate\n          el: el,\n          match: match\n        };\n      }\n    } else {\n      relativeOp = relativeExpr[match.nextCombinator];\n\n      if (relativeOp.immediate) {\n        // retreat but advance startEl\n        return {\n          el: dir(startEl, relativeExpr[startMatch.nextCombinator].dir),\n          match: startMatch\n        };\n      } else {\n        // advance (before immediate match + jump unmatched)\n        return {\n          el: el && dir(el, relativeOp.dir),\n          match: match\n        };\n      }\n    }\n  } while (el); // only occur when match immediate\n\n\n  return {\n    el: dir(startEl, relativeExpr[startMatch.nextCombinator].dir),\n    match: startMatch\n  };\n} // find fixed part, fixed with seeds\n\n\nfunction findFixedMatchFromHead(el, head) {\n  var relativeOp,\n      cur = head;\n\n  do {\n    if (!singleMatch(el, cur)) {\n      return null;\n    }\n\n    cur = cur.prev;\n\n    if (!cur) {\n      return true;\n    }\n\n    relativeOp = relativeExpr[cur.nextCombinator];\n    el = dir(el, relativeOp.dir);\n  } while (el && relativeOp.immediate);\n\n  if (!el) {\n    return null;\n  }\n\n  return {\n    el: el,\n    match: cur\n  };\n}\n\nfunction genId(el) {\n  var selectorId;\n\n  if (isContextXML) {\n    if (!(selectorId = el.getAttribute(EXPANDO_SELECTOR_KEY))) {\n      el.setAttribute(EXPANDO_SELECTOR_KEY, selectorId = +new Date() + '_' + ++uuid);\n    }\n  } else {\n    if (!(selectorId = el[EXPANDO_SELECTOR_KEY])) {\n      selectorId = el[EXPANDO_SELECTOR_KEY] = +new Date() + '_' + ++uuid;\n    }\n  }\n\n  return selectorId;\n}\n\nfunction matchSub(el, match) {\n  var selectorId = genId(el),\n      matchKey;\n  matchKey = selectorId + '_' + (match.order || 0);\n\n  if (matchKey in subMatchesCache) {\n    return subMatchesCache[matchKey];\n  }\n\n  subMatchesCache[matchKey] = matchSubInternal(el, match);\n  return subMatchesCache[matchKey];\n} // recursive match by sub selector string from right to left\n// grouped by immediate selectors\n\n\nfunction matchSubInternal(el, match) {\n  var matchImmediateRet = matchImmediate(el, match);\n\n  if (matchImmediateRet === true) {\n    return true;\n  } else {\n    el = matchImmediateRet.el;\n    match = matchImmediateRet.match;\n\n    while (el) {\n      if (matchSub(el, match)) {\n        return true;\n      }\n\n      el = dir(el, relativeExpr[match.nextCombinator].dir);\n    }\n\n    return false;\n  }\n}\n\nfunction select(str, context, seeds) {\n  if (!caches[str]) {\n    caches[str] = parser.parse(str);\n  }\n\n  var selector = caches[str],\n      groupIndex = 0,\n      groupLen = selector.length,\n      contextDocument,\n      group,\n      ret = [];\n\n  if (seeds) {\n    context = context || seeds[0].ownerDocument;\n  }\n\n  contextDocument = context && context.ownerDocument || typeof document !== 'undefined' && document;\n\n  if (context && context.nodeType === 9 && !contextDocument) {\n    contextDocument = context;\n  }\n\n  context = context || contextDocument;\n  isContextXML = isXML(context);\n\n  for (; groupIndex < groupLen; groupIndex++) {\n    resetStatus();\n    group = selector[groupIndex];\n    var suffix = group.suffix,\n        suffixIndex,\n        suffixLen,\n        seedsIndex,\n        mySeeds = seeds,\n        seedsLen,\n        id = null;\n\n    if (!mySeeds) {\n      if (suffix && !isContextXML) {\n        suffixIndex = 0;\n        suffixLen = suffix.length;\n\n        for (; suffixIndex < suffixLen; suffixIndex++) {\n          var singleSuffix = suffix[suffixIndex];\n\n          if (singleSuffix.t === 'id') {\n            id = singleSuffix.value;\n            break;\n          }\n        }\n      }\n\n      if (id) {\n        // http://yiminghe.github.io/lab/playground/fragment-selector/selector.html\n        var doesNotHasById = !context.getElementById,\n            contextInDom = util.contains(contextDocument, context),\n            tmp = doesNotHasById ? contextInDom ? contextDocument.getElementById(id) : null : context.getElementById(id); // id bug\n        // https://github.com/kissyteam/kissy/issues/67\n\n        if (!tmp && doesNotHasById || tmp && getAttr(tmp, 'id') !== id) {\n          var tmps = util.getElementsByTagName('*', context),\n              tmpLen = tmps.length,\n              tmpI = 0;\n\n          for (; tmpI < tmpLen; tmpI++) {\n            tmp = tmps[tmpI];\n\n            if (getAttr(tmp, 'id') === id) {\n              mySeeds = [tmp];\n              break;\n            }\n          }\n\n          if (tmpI === tmpLen) {\n            mySeeds = [];\n          }\n        } else {\n          if (contextInDom && tmp && context !== contextDocument) {\n            tmp = util.contains(context, tmp) ? tmp : null;\n          }\n\n          mySeeds = tmp ? [tmp] : [];\n        }\n      } else {\n        mySeeds = util.getElementsByTagName(group.value || '*', context);\n      }\n    }\n\n    seedsIndex = 0;\n    seedsLen = mySeeds.length;\n\n    if (!seedsLen) {\n      continue;\n    }\n\n    for (; seedsIndex < seedsLen; seedsIndex++) {\n      var seed = mySeeds[seedsIndex];\n      var matchHead = findFixedMatchFromHead(seed, group);\n\n      if (matchHead === true) {\n        ret.push(seed);\n      } else if (matchHead) {\n        if (matchSub(matchHead.el, matchHead.match)) {\n          ret.push(seed);\n        }\n      }\n    }\n  }\n\n  if (groupLen > 1) {\n    ret = util.unique(ret);\n  }\n\n  return ret;\n}\n\nmodule.exports = select;\n\nselect.parse = function (str) {\n  return parser.parse(str);\n};\n\nselect.matches = matches;\nselect.util = util;\nselect.version = '@VERSION@';\n/**\n * @ignore\n * note 2013-03-28\n *  - use recursive call to replace backtracking algorithm\n *\n * refer\n *  - http://www.w3.org/TR/selectors/\n *  - http://www.impressivewebs.com/browser-support-css3-selectors/\n *  - http://blogs.msdn.com/ie/archive/2010/05/13/the-css-corner-css3-selectors.aspx\n *  - http://sizzlejs.com/\n */","map":null,"metadata":{},"sourceType":"script"}