{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _d3Scale = require('d3-scale');\n\nvar _d = require('d3');\n\nvar _d3TimeFormat = require('d3-time-format');\n\nvar _d3Array = require('d3-array');\n\nvar _reactFauxDom = require('react-faux-dom');\n\nvar _reactFauxDom2 = _interopRequireDefault(_reactFauxDom);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _radium = require('radium');\n\nvar _lodash = require('lodash.merge');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _shared = require('../../shared');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar dateParser = {};\nvar color = (0, _d.scaleOrdinal)(_d.schemeCategory20).domain((0, _d.range)(0, 20));\nvar axisMargin = 18;\n\nvar ScatterplotChart = function (_PureComponent) {\n  (0, _inherits3.default)(ScatterplotChart, _PureComponent);\n  (0, _createClass3.default)(ScatterplotChart, null, [{\n    key: 'propTypes',\n    get: function get() {\n      return {\n        axes: _propTypes2.default.bool,\n        axisLabels: _propTypes2.default.shape({\n          x: _propTypes2.default.string,\n          y: _propTypes2.default.string\n        }),\n        clickHandler: _propTypes2.default.func,\n        config: _propTypes2.default.array,\n        data: _propTypes2.default.array.isRequired,\n        datePattern: _propTypes2.default.string,\n        yAxisOrientRight: _propTypes2.default.bool,\n        dotRadius: _propTypes2.default.number,\n        verticalGrid: _propTypes2.default.bool,\n        grid: _propTypes2.default.bool,\n        height: _propTypes2.default.number,\n        useLegend: _propTypes2.default.bool,\n        margin: _propTypes2.default.object,\n        mouseOverHandler: _propTypes2.default.func,\n        mouseOutHandler: _propTypes2.default.func,\n        mouseMoveHandler: _propTypes2.default.func,\n        style: _propTypes2.default.object,\n        tickTimeDisplayFormat: _propTypes2.default.string,\n        width: _propTypes2.default.number,\n        xDomainRange: _propTypes2.default.array,\n        yDomainRange: _propTypes2.default.array,\n        xTickNumber: _propTypes2.default.number,\n        yTickNumber: _propTypes2.default.number,\n        xTicks: _propTypes2.default.number,\n        yTicks: _propTypes2.default.number,\n        xType: _propTypes2.default.string,\n        yType: _propTypes2.default.string\n      };\n    }\n  }, {\n    key: 'defaultProps',\n    get: function get() {\n      return {\n        axes: false,\n        axisLabels: {\n          x: '',\n          y: ''\n        },\n        clickHandler: function clickHandler() {},\n        config: [],\n        datePattern: '%d-%b-%y',\n        dotRadius: 5,\n        grid: false,\n        mouseOverHandler: function mouseOverHandler() {},\n        mouseOutHandler: function mouseOutHandler() {},\n        mouseMoveHandler: function mouseMoveHandler() {},\n        width: 320,\n        height: 180,\n        xType: 'linear',\n        yType: 'linear'\n      };\n    }\n  }]);\n\n  function ScatterplotChart(props) {\n    (0, _classCallCheck3.default)(this, ScatterplotChart);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (ScatterplotChart.__proto__ || (0, _getPrototypeOf2.default)(ScatterplotChart)).call(this, props));\n\n    _this.uid = (0, _shared.createUniqueID)(props);\n    return _this;\n  }\n\n  (0, _createClass3.default)(ScatterplotChart, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.initialise();\n      var ref = this.refs.scatterplotChart;\n      (0, _shared.createCircularTicks)(ref);\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.transition();\n      var ref = this.refs.scatterplotChart;\n      (0, _shared.createCircularTicks)(ref);\n    }\n  }, {\n    key: 'getScale',\n    value: function getScale(type) {\n      switch (type) {\n        case 'time':\n          return (0, _d.scaleTime)();\n\n        case 'text':\n          return (0, _d3Scale.scalePoint)();\n\n        default:\n          return (0, _d3Scale.scaleLinear)();\n      }\n    }\n  }, {\n    key: 'getDataConfig',\n    value: function getDataConfig(type) {\n      var config = this.props.config;\n      var index = config.findIndex(function (item) {\n        return item.type === type;\n      });\n      return config[index];\n    }\n  }, {\n    key: 'getFill',\n    value: function getFill(data) {\n      var configItem = this.getDataConfig(data.type);\n      return configItem ? configItem.color : color(data.type);\n    }\n  }, {\n    key: 'getRadius',\n    value: function getRadius(data, dataItem, dotRadius) {\n      if (typeof data[0].z !== 'undefined') {\n        var rangeRadius = (0, _d3Array.extent)(data, function (d) {\n          return d.z;\n        });\n        var mn = rangeRadius[0];\n        var mx = rangeRadius[1];\n        var p = (dataItem.z - mn) / (mx - mn);\n        var minRad = 5;\n        var maxRad = 20;\n        var rad = minRad + (maxRad - minRad) * p;\n        return rad;\n      }\n\n      return dotRadius;\n    }\n  }, {\n    key: 'getStroke',\n    value: function getStroke(data) {\n      var configItem = this.getDataConfig(data.type);\n      return configItem ? configItem.stroke : 'none'; // typeof configItem !== 'undefined' ? configItem.stroke : 'none';\n    }\n  }, {\n    key: 'getCircles',\n    value: function getCircles() {\n      var uid = this.uid;\n      return (0, _d.select)('#scatterplot-chart-' + uid).selectAll('circle'); // '.dot'\n    }\n  }, {\n    key: 'getXAxis',\n    value: function getXAxis() {\n      var uid = this.uid;\n      return (0, _d.select)('#scatterplot-x-axis-' + uid);\n    }\n  }, {\n    key: 'getYAxis',\n    value: function getYAxis() {\n      var uid = this.uid;\n      return (0, _d.select)('#scatterplot-y-axis-' + uid);\n    }\n  }, {\n    key: 'createDomainRangeGenerator',\n    value: function createDomainRangeGenerator(axisType, domainRange, data, type, length, yAxisOrientRight) {\n      var _this2 = this;\n\n      var dataIndex = axisType === 'x' ? 'x' : 'y';\n      var axis = void 0;\n      var minAmount = void 0;\n      var maxAmount = void 0;\n\n      var parseDate = function parseDate(v) {\n        return _this2.parseDate(v);\n      };\n\n      switch (type) {\n        case 'text':\n          axis = (0, _d3Scale.scalePoint)();\n          axis.domain(data.map(function (d) {\n            return d[dataIndex];\n          }), 1).range([0, length]).padding(1);\n          break;\n\n        case 'linear':\n          axis = (0, _d3Scale.scaleLinear)();\n          minAmount = (0, _d.min)(data, function (d) {\n            return d[dataIndex];\n          });\n          maxAmount = (0, _d.max)(data, function (d) {\n            return d[dataIndex];\n          });\n\n          if (domainRange) {\n            axis.domain(domainRange); // calculateDomainRange(domainRange, type, parseDate));\n          } else {\n            // set initial domain\n            axis.domain([minAmount, maxAmount]); // calculate 1 tick offset\n\n            var ticks = axis.ticks();\n            minAmount = yAxisOrientRight && axisType === 'x' ? minAmount : minAmount - (ticks[1] - ticks[0]);\n            maxAmount = yAxisOrientRight && axisType === 'x' ? maxAmount + (ticks[1] - ticks[0]) : maxAmount;\n            axis.domain([minAmount, maxAmount]);\n          }\n\n          axis.range(axisType === 'x' ? [0, length] : [length, 0]);\n          break;\n\n        case 'time':\n          axis = (0, _d.scaleTime)();\n          axis.domain(domainRange ? (0, _shared.calculateDomainRange)(domainRange) : (0, _d3Array.extent)(data, function (d) {\n            return parseDate(d[dataIndex]);\n          })).range(axisType === 'x' ? [0, length] : [length, 0]);\n          break;\n\n        default:\n          break;\n      }\n\n      return axis;\n    }\n  }, {\n    key: 'calculateMargin',\n    value: function calculateMargin(axes, spacer, yAxisOrientRight) {\n      if (yAxisOrientRight) {\n        return axes ? {\n          top: 24,\n          right: 48,\n          bottom: 24,\n          left: 24\n        } : {\n          top: spacer,\n          right: spacer,\n          bottom: spacer,\n          left: spacer\n        };\n      }\n\n      return axes ? {\n        top: 24,\n        right: 24,\n        bottom: 24,\n        left: 48\n      } : {\n        top: spacer,\n        right: spacer,\n        bottom: spacer,\n        left: spacer\n      };\n    }\n  }, {\n    key: 'calculateInnerW',\n    value: function calculateInnerW(w, m) {\n      return w - (m.left + m.right);\n    }\n  }, {\n    key: 'calculateInnerH',\n    value: function calculateInnerH(h, m) {\n      var dotRadius = this.props.dotRadius;\n      return h - (m.top + m.bottom + dotRadius * 2);\n    }\n  }, {\n    key: 'calculateXAxis',\n    value: function calculateXAxis(_ref) {\n      var h = _ref.h,\n          x = _ref.x;\n      var _props = this.props,\n          xType = _props.xType,\n          tickTimeDisplayFormat = _props.tickTimeDisplayFormat,\n          xTickNumber = _props.xTickNumber,\n          grid = _props.grid,\n          verticalGrid = _props.verticalGrid,\n          xTicks = _props.xTicks;\n      var axis = (0, _d.axisBottom)(x);\n\n      if (xType === 'time' && tickTimeDisplayFormat) {\n        axis.tickFormat((0, _d.timeFormat)(tickTimeDisplayFormat));\n      }\n\n      if (xTickNumber) {\n        axis.ticks(xTickNumber);\n      }\n\n      if (grid && verticalGrid) {\n        axis.tickSize(-h, 6).tickPadding(15);\n      } else {\n        axis.tickSize(0).tickPadding(15);\n      }\n\n      if (xTicks) {\n        axis.ticks(xTicks);\n      }\n\n      return axis;\n    }\n  }, {\n    key: 'calculateYAxis',\n    value: function calculateYAxis(_ref2) {\n      var y = _ref2.y,\n          innerW = _ref2.innerW;\n      var _props2 = this.props,\n          grid = _props2.grid,\n          yTicks = _props2.yTicks,\n          yAxisOrientRight = _props2.yAxisOrientRight;\n      var axis = yAxisOrientRight ? (0, _d.axisRight)(y) : (0, _d.axisLeft)(y);\n\n      if (grid) {\n        axis.tickSize(-innerW, 6).tickPadding(12);\n      } else {\n        axis.tickPadding(10);\n      }\n\n      if (yTicks) {\n        axis.ticks(yTicks);\n      }\n\n      return axis;\n    }\n  }, {\n    key: 'initialise',\n    value: function initialise() {\n      var axes = this.props.axes;\n      var p = this.calculateChartParameters();\n\n      if (axes) {\n        this.initialiseXAxis(p);\n        this.initialiseYAxis(p);\n      }\n\n      this.initialiseChart(p);\n    }\n  }, {\n    key: 'initialiseXAxis',\n    value: function initialiseXAxis(_ref3) {\n      var xAxis = _ref3.xAxis;\n      this.getXAxis().call(xAxis);\n    }\n  }, {\n    key: 'initialiseYAxis',\n    value: function initialiseYAxis(_ref4) {\n      var yAxis = _ref4.yAxis;\n      this.getYAxis().call(yAxis);\n    }\n  }, {\n    key: 'initialiseChart',\n    value: function initialiseChart(_ref5) {\n      var _this3 = this;\n\n      var x = _ref5.x,\n          y = _ref5.y;\n      var _props3 = this.props,\n          data = _props3.data,\n          dotRadius = _props3.dotRadius,\n          xType = _props3.xType,\n          mouseOverHandler = _props3.mouseOverHandler,\n          mouseOutHandler = _props3.mouseOutHandler,\n          mouseMoveHandler = _props3.mouseMoveHandler,\n          clickHandler = _props3.clickHandler;\n\n      var calculateDate = function calculateDate(v) {\n        return _this3.parseDate(v);\n      };\n\n      var calculateR = function calculateR(d) {\n        return _this3.getRadius(data, d, dotRadius);\n      };\n\n      var calculateCX = function calculateCX(d) {\n        return xType === 'time' ? x(calculateDate(d.x)) : x(d.x);\n      };\n\n      var calculateCY = function calculateCY(d) {\n        return y(d.y);\n      };\n\n      var getFill = function getFill(d) {\n        return _this3.getFill(d);\n      };\n\n      var getStroke = function getStroke(d) {\n        return _this3.getStroke(d);\n      };\n\n      var mouseOver = function mouseOver(d) {\n        return mouseOverHandler(d, _d.event);\n      };\n\n      var mouseOut = function mouseOut(d) {\n        return mouseOutHandler(d, _d.event);\n      };\n\n      var mouseMove = function mouseMove(d) {\n        return mouseMoveHandler(d, _d.event);\n      };\n\n      var click = function click(d) {\n        return clickHandler(d, _d.event);\n      };\n\n      var circle = this.getCircles().data(data);\n      circle.enter().append('circle').attr('class', 'dot').attr('r', calculateR).attr('cx', calculateCX).attr('cy', calculateCY).style('fill', getFill).style('stroke', getStroke).on('mouseover', mouseOver).on('mouseout', mouseOut).on('mousemove', mouseMove).on('click', click);\n    }\n  }, {\n    key: 'transition',\n    value: function transition() {\n      var axes = this.props.axes;\n      var p = this.calculateChartParameters();\n\n      if (axes) {\n        this.transitionXAxis(p);\n        this.transitionYAxis(p);\n      }\n\n      this.transitionChart(p);\n    }\n  }, {\n    key: 'transitionXAxis',\n    value: function transitionXAxis(_ref6) {\n      var xAxis = _ref6.xAxis;\n      this.getXAxis().transition().duration(750).call(xAxis);\n    }\n  }, {\n    key: 'transitionYAxis',\n    value: function transitionYAxis(_ref7) {\n      var yAxis = _ref7.yAxis;\n      this.getYAxis().transition().duration(750).call(yAxis);\n    }\n  }, {\n    key: 'transitionChart',\n    value: function transitionChart(_ref8) {\n      var _this4 = this;\n\n      var x = _ref8.x,\n          y = _ref8.y;\n      var _props4 = this.props,\n          data = _props4.data,\n          dotRadius = _props4.dotRadius,\n          xType = _props4.xType,\n          mouseOverHandler = _props4.mouseOverHandler,\n          mouseOutHandler = _props4.mouseOutHandler,\n          mouseMoveHandler = _props4.mouseMoveHandler,\n          clickHandler = _props4.clickHandler;\n\n      var calculateDate = function calculateDate(v) {\n        return _this4.parseDate(v);\n      };\n\n      var calculateR = function calculateR(d) {\n        return _this4.getRadius(data, d, dotRadius);\n      };\n\n      var calculateCX = function calculateCX(d) {\n        return xType === 'time' ? x(calculateDate(d.x)) : x(d.x);\n      };\n\n      var calculateCY = function calculateCY(d) {\n        return y(d.y);\n      };\n\n      var mouseOver = function mouseOver(d) {\n        return mouseOverHandler(d, _d.event);\n      };\n\n      var mouseOut = function mouseOut(d) {\n        return mouseOutHandler(d, _d.event);\n      };\n\n      var mouseMove = function mouseMove(d) {\n        return mouseMoveHandler(d, _d.event);\n      };\n\n      var click = function click(d) {\n        return clickHandler(d, _d.event);\n      };\n\n      var getFill = function getFill(d) {\n        return _this4.getFill(d);\n      };\n\n      var getStroke = function getStroke(d) {\n        return _this4.getStroke(d);\n      };\n\n      var n = data.length;\n      var circle = this.getCircles().data(data);\n\n      if (n) {\n        circle.transition().duration(750).attr('r', calculateR).attr('cx', calculateCX).attr('cy', calculateCY);\n        circle.style('fill', getFill).style('stroke', getStroke).on('mouseover', mouseOver).on('mouseout', mouseOut).on('mousemove', mouseMove).on('click', click);\n        circle.enter().append('circle').attr('class', 'dot').attr('r', calculateR).attr('cx', calculateCX).attr('cy', calculateCY).style('fill', getFill).style('stroke', getStroke).on('mouseover', mouseOver).on('mouseout', mouseOut).on('mousemove', mouseMove).on('click', click);\n      }\n\n      circle.exit().remove();\n    }\n  }, {\n    key: 'createSvgNode',\n    value: function createSvgNode(_ref9) {\n      var m = _ref9.m,\n          w = _ref9.w,\n          h = _ref9.h;\n      var node = new _reactFauxDom2.default.Element('svg');\n      node.setAttribute('width', w + m.left + m.right);\n      node.setAttribute('height', h + m.top + m.bottom);\n      return node;\n    }\n  }, {\n    key: 'createSvgRoot',\n    value: function createSvgRoot(_ref10) {\n      var node = _ref10.node,\n          m = _ref10.m;\n      return (0, _d.select)(node).append('g').attr('transform', 'translate(' + m.left + ', ' + m.top + ')');\n    }\n  }, {\n    key: 'createXAxis',\n    value: function createXAxis(_ref11) {\n      var m = _ref11.m,\n          innerW = _ref11.innerW,\n          innerH = _ref11.innerH,\n          root = _ref11.root;\n      var _props5 = this.props,\n          yAxisOrientRight = _props5.yAxisOrientRight,\n          label = _props5.axisLabels.x;\n      var uid = this.uid;\n      var group = root.append('g').attr('class', 'x axis').attr('id', 'scatterplot-x-axis-' + uid).attr('transform', 'translate(0, ' + innerH + ')');\n\n      if (label) {\n        group.append('text').attr('class', 'label').attr('x', yAxisOrientRight ? 0 : innerW).attr('y', m.bottom + axisMargin).style('text-anchor', yAxisOrientRight ? 'start' : 'end').text(label);\n      }\n    }\n  }, {\n    key: 'createYAxis',\n    value: function createYAxis(_ref12) {\n      var m = _ref12.m,\n          innerW = _ref12.innerW,\n          root = _ref12.root;\n      var _props6 = this.props,\n          yAxisOrientRight = _props6.yAxisOrientRight,\n          label = _props6.axisLabels.y;\n      var uid = this.uid;\n      var group = root.append('g').attr('class', 'y axis').attr('id', 'scatterplot-y-axis-' + uid).attr('transform', yAxisOrientRight ? 'translate(' + innerW + ', 0)' : 'translate(0, 0)');\n\n      if (label) {\n        group.append('text').attr('class', 'label').attr('transform', 'rotate(-90)').attr('y', yAxisOrientRight ? -25 + m.right : 10 - m.left).attr('dy', '.71em').style('text-anchor', 'end').text(label);\n      }\n    }\n  }, {\n    key: 'createScatterplotChart',\n    value: function createScatterplotChart(_ref13) {\n      var root = _ref13.root;\n      var uid = this.uid;\n      root.append('g').attr('id', 'scatterplot-chart-' + uid);\n    }\n  }, {\n    key: 'createStyle',\n    value: function createStyle() {\n      var _props7 = this.props,\n          style = _props7.style,\n          grid = _props7.grid,\n          verticalGrid = _props7.verticalGrid,\n          yAxisOrientRight = _props7.yAxisOrientRight;\n      var uid = this.uid;\n      var scope = '.scatterplot-chart-' + uid;\n      var axisStyles = (0, _shared.getAxisStyles)(grid, verticalGrid, yAxisOrientRight);\n      var rules = (0, _lodash2.default)({}, _shared.defaultStyles, style, axisStyles);\n      return _react2.default.createElement(_radium.Style, {\n        scopeSelector: scope,\n        rules: rules\n      });\n    }\n  }, {\n    key: 'parseDate',\n    value: function parseDate(v) {\n      var datePattern = this.props.datePattern;\n      var datePatternParser = dateParser[datePattern] || (dateParser[datePattern] = (0, _d3TimeFormat.timeParse)(datePattern));\n      return datePatternParser(v);\n    }\n  }, {\n    key: 'calculateChartParameters',\n    value: function calculateChartParameters() {\n      var _this5 = this;\n\n      var _props8 = this.props,\n          axes = _props8.axes,\n          data = _props8.data,\n          margin = _props8.margin,\n          width = _props8.width,\n          height = _props8.height,\n          dotRadius = _props8.dotRadius,\n          xType = _props8.xType,\n          yType = _props8.yType,\n          xDomainRange = _props8.xDomainRange,\n          yDomainRange = _props8.yDomainRange,\n          yAxisOrientRight = _props8.yAxisOrientRight;\n      /*\n       * We could \"bind\"!\n       */\n\n      var parseDate = function parseDate(v) {\n        return _this5.parseDate(v);\n      };\n\n      var m = margin || this.calculateMargin(axes, dotRadius * 2, yAxisOrientRight);\n      var w = width;\n      var h = height + dotRadius * 3;\n      var innerW = this.calculateInnerW(width, m);\n      var innerH = this.calculateInnerH(height, m);\n      var defaultXDomainRange = (0, _shared.calculateDomainRange)(xDomainRange, xType, parseDate);\n      var defaultYDomainRange = (0, _shared.calculateDomainRange)(yDomainRange, yType, parseDate);\n      var x = this.createDomainRangeGenerator('x', defaultXDomainRange, data, xType, innerW, yAxisOrientRight);\n      var y = this.createDomainRangeGenerator('y', defaultYDomainRange, data, yType, innerH, yAxisOrientRight);\n      var xAxis = this.calculateXAxis({\n        m: m,\n        h: h,\n        x: x,\n        innerW: innerW\n      });\n      var yAxis = this.calculateYAxis({\n        m: m,\n        y: y,\n        innerW: innerW\n      });\n      var node = this.createSvgNode({\n        m: m,\n        w: w,\n        h: h\n      });\n      var root = this.createSvgRoot({\n        node: node,\n        m: m\n      });\n      return {\n        m: m,\n        w: w,\n        h: h,\n        innerW: innerW,\n        innerH: innerH,\n        x: x,\n        y: y,\n        xAxis: xAxis,\n        yAxis: yAxis,\n        node: node,\n        root: root\n      };\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var axes = this.props.axes;\n      var p = this.calculateChartParameters();\n\n      if (axes) {\n        this.createXAxis(p);\n        this.createYAxis(p);\n      }\n\n      this.createScatterplotChart(p);\n      var uid = this.uid;\n      var className = 'scatterplot-chart-' + uid;\n      var node = p.node;\n      return _react2.default.createElement('div', {\n        ref: 'scatterplotChart',\n        className: className\n      }, this.createStyle(), node.toReact());\n    }\n  }]);\n  return ScatterplotChart;\n}(_react.PureComponent);\n\nexports.default = ScatterplotChart;\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}